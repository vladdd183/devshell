# configurations/xonsh/xonshrc
$PROMPT = '{cwd} $ '

# Добавьте дополнительные настройки xonsh здесь


xpip install xontrib-abbrevs --break-system-packages
xontrib load abbrevs

abbrevs['dvr'] = 'devbox run <edit> #some test'

#aliases['source'] = 'source-bash'

$CACHIX_AUTH_TOKEN ='eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiIyYzMyNzY4NS05OGUzLTRiYWItOTA0MC0wMmUyYWQ5YTBjZDAiLCJzY29wZXMiOiJjYWNoZSJ9.gnMzZQAOl5RR3_s4_XQvSGDhpKZhzggP85DPHe5URO4'

'''
xontrib load readable-traceback
#xontrib load argcomplete
xontrib load docker_tabcomplete
xontrib load jedi
#xontrib load autojump

$OPENROUTER_API_KEY="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"
$_Z_CASE_SENSITIVE=False
xontrib load z

xontrib load gruvbox
$XONSH_COLOR_STYLE="gruvbox"

xontrib load sh
xontrib load pipeliner
xontrib load xlsd


$XONSH_CAPTURE_ALWAYS=True
xontrib load output_search

#======================
xontrib load onepath
def _cdls(args):
     cd @(args[0])
     if int($(ls | wc -l).strip()) < 100:
         ls -a
aliases['cdls'] = _cdls
del _cdls


# export PYENV_ROOT="$HOME/.pyenv"
# command -v pyenv >/dev/null || export PATH="$PYENV_ROOT/bin:$PATH"
# eval "$(pyenv init -)"
import os

$PYENV_ROOT = os.path.expanduser('~/.pyenv')
if 'pyenv' not in $PATH:
    $PATH.append($PYENV_ROOT + '/bin')


pyenv init - > /tmp/pyenv
source-bash /tmp/pyenv > /dev/null




import pandas as pd
def _view_csv_with_pandas(args):
    print(pd.read_csv(args[0]))

aliases['view_csv_with_pandas'] = _view_csv_with_pandas
del _view_csv_with_pandas


$XONTRIB_ONEPATH_ACTIONS['<DIR>'] = 'cdls'
$XONTRIB_ONEPATH_ACTIONS['.xonshrc'] = 'vim'         # vim for `.xonshrc` file
$XONTRIB_ONEPATH_ACTIONS['*.log'] = 'tail'           # tail for text type *.log files
$XONTRIB_ONEPATH_ACTIONS['text/plain.txt'] = 'less'  # less for plain text *.txt files 
$XONTRIB_ONEPATH_ACTIONS['application/zip'] = 'als'  # list files in zip file using atool
$XONTRIB_ONEPATH_ACTIONS['application/csv'] = 'view_csv_with_pandas'
#======================



#======================
xontrib load fzf-widgets
$fzf_history_binding = "c-r"  # Ctrl+R
$fzf_ssh_binding = "c-s"      # Ctrl+S
$fzf_file_binding = "c-t"      # Ctrl+T
$fzf_dir_binding = "c-g"      # Ctrl+G
$fzf_find_command = "fd"
$fzf_find_dirs_command = "fd -t d"
#======================

# >>> conda initialize >>>
# !! Contents within this block are managed by 'conda init' !!
if !(test -f "/usr/bin/conda"):
    import sys as _sys
    from types import ModuleType as _ModuleType
    _mod = _ModuleType("xontrib.conda",
                    "Autogenerated from $(/usr/bin/conda shell.xonsh hook)")
    __xonsh__.execer.exec($("/usr/bin/conda" "shell.xonsh" "hook"),
                        glbs=_mod.__dict__,
                        filename="$(/usr/bin/conda shell.xonsh hook)")
    _sys.modules["xontrib.conda"] = _mod
    del _sys, _mod, _ModuleType
# <<< conda initialize <<<



# ---------------- inshellisense shell plugin ----------------
#if 'ISTERM' not in ${...} and $XONSH_INTERACTIVE:
#    if $XONSH_LOGIN:
#        is -s xonsh --login ; exit
#    else:
#        is -s xonsh ; exit
execx($(zoxide init xonsh), 'exec', __xonsh__.ctx, filename='zoxide')
'''
_ATUIN_BIND_CTRL_R=True
_ATUIN_BIND_UP_ARROW=True
import subprocess

from prompt_toolkit.application.current import get_app
from prompt_toolkit.filters import Condition
from prompt_toolkit.keys import Keys


$ATUIN_SESSION=$(atuin uuid).rstrip('\n')

@events.on_precommand
def _atuin_precommand(cmd: str):
    cmd = cmd.rstrip("\n")
    $ATUIN_HISTORY_ID = $(atuin history start -- @(cmd)).rstrip("\n")


@events.on_postcommand
def _atuin_postcommand(cmd: str, rtn: int, out, ts):
    if "ATUIN_HISTORY_ID" not in ${...}:
        return

    duration = ts[1] - ts[0]
    # Duration is float representing seconds, but atuin expects integer of nanoseconds
    nanos = round(duration * 10 ** 9)
    with ${...}.swap(ATUIN_LOG="error"):
        # This causes the entire .xonshrc to be re-executed, which is incredibly slow
        # This happens when using a subshell and using output redirection at the same time
        # For more details, see https://github.com/xonsh/xonsh/issues/5224
        # (atuin history end --exit @(rtn) -- $ATUIN_HISTORY_ID &) > /dev/null 2>&1
        atuin history end --exit @(rtn) --duration @(nanos) -- $ATUIN_HISTORY_ID > /dev/null 2>&1
    del $ATUIN_HISTORY_ID


def _search(event, extra_args: list[str]):
    buffer = event.current_buffer
    cmd = ["atuin", "search", "--interactive", *extra_args]
    # We need to explicitly pass in xonsh env, in case user has set XDG_HOME or something else that matters
    env = ${...}.detype()
    env["ATUIN_SHELL_XONSH"] = "t"
    env["ATUIN_QUERY"] = buffer.text

    p = subprocess.run(cmd, stderr=subprocess.PIPE, encoding="utf-8", env=env)
    result = p.stderr.rstrip("\n")
    # redraw prompt - necessary if atuin is configured to run inline, rather than fullscreen
    event.cli.renderer.erase()

    if not result:
        return

    buffer.reset()
    if result.startswith("__atuin_accept__:"):
        buffer.insert_text(result[17:])
        buffer.validate_and_handle()
    else:
        buffer.insert_text(result)


@events.on_ptk_create
def _custom_keybindings(bindings, **kw):
    if _ATUIN_BIND_CTRL_R:
        @bindings.add(Keys.ControlR)
        def r_search(event):
            _search(event, extra_args=[])

    if _ATUIN_BIND_UP_ARROW:
        @Condition
        def should_search():
            buffer = get_app().current_buffer
            # disable keybind when there is an active completion, so
            # that up arrow can be used to navigate completion menu
            if buffer.complete_state is not None:
                return False
            # similarly, disable when buffer text contains multiple lines
            if '\n' in buffer.text:
                return False

            return True

        @bindings.add(Keys.Up, filter=should_search)
        def up_search(event):
            _search(event, extra_args=["--shell-up-key-binding"])

